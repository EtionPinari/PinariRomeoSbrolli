sig Market{
dispensers: some TicketDispenser,
cashDesks: some CashDesk,
entrances: some QRCodeReader, //Representing the entrance of the market, with turnstiles and relative QRCode reader
freeExit: some QRCodeReader,	//Representing the exit for users that did decide to not buy or that did not find what they wanted
manager: one StoreManager,	
departments: set Department,
ticketManager : one TicketSystem
}{
freeExit & entrances  = none
freeExit & cashDesks.reader = none
entrances & cashDesks.reader = none
}

sig TicketSystem{
maxUsersPerSlot: one Int,
insideMarket: set Ticket,
line: set Ticket,
pastTickets: set Ticket,
currentTimeSlot: one TimeSlot,
currentDate: one Date,
availableSlots: Date -> TimeSlot
}{ //no ticket is in more different states at the same time
#(insideMarket & line)=0
#(insideMarket & pastTickets)=0
#(line & pastTickets)=0
//all tickets insideMarket are tickets booked for the current Date and Time Slot
all t: Ticket | t in insideMarket implies (t.ticketDate = currentDate and t.ticketTimeSlot = currentTimeSlot)
//Available Dates and Time Slots are the ones for which the number of tickets is less than the max number admitted to grant safety and that
// are not  Dates or Slots different from the current for which there are past tickets (No available Slots in past dates)
all d:Date, ts:TimeSlot | (d->ts) in availableSlots iff (#((insideMarket + line) &  ticketDate.d & ticketTimeSlot.ts) < maxUsersPerSlot and 
											no t: Ticket | t in pastTickets and (t.ticketDate != currentDate and d=t.ticketDate or t.ticketTimeSlot != currentTimeSlot and d=t.ticketDate and ts=t.ticketTimeSlot  ))
maxUsersPerSlot > 0
}

sig TicketDispenser{
distributedTickets: set PhysicalTicket
}

sig QRCode{}

sig QRCodeReader{
scanned: set QRCode
}

sig CashDesk{
reader: one QRCodeReader
}

abstract sig Person{}

sig StoreManager extends Person{}

abstract sig SafetyStatus{}
one sig Safe extends SafetyStatus{}
one sig UnSafe extends SafetyStatus{}

abstract sig User extends Person{
userStatus: one SafetyStatus
}
sig VirtualUser extends User{
userVTickets: set VirtualTicket,
userVisits: set Visit,
userDevice: some SmartDevice
}

sig PhysicalUser extends User{
userPTickets: set PhysicalTicket
}

sig Date{}
sig TimeSlot{}

abstract sig Ticket{
ticketDate: one Date,
ticketTimeSlot: one TimeSlot,
ticketCode: one QRCode
}
sig PhysicalTicket extends Ticket{}
sig VirtualTicket extends Ticket{}
sig Visit extends Ticket{
shoppingListCategories : set Category,
shoppingListItems : set Item
}

sig Item{}

sig Category{
products: some Item
}

sig Department{
categories: some Category
}

sig SmartDevice{
localizationDevice: lone GPS
}

sig GPS{}


///////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////UTILITIES////////////////////////////////////////

//gets all the qr code readers that scanned the given ticket
fun scannedBy[t: Ticket] : set QRCodeReader {
 scanned.(t.ticketCode)
}

//gets all tickets managed by the given ticket system
fun getAllTickets[ts: TicketSystem] : set Ticket {
 ts.insideMarket + ts.line + ts.pastTickets
}

//gets all the visits and tickets of the given virtual user
fun getVUserTicketsAndVisits[u: VirtualUser] : set Ticket {
u.(userVTickets + userVisits)
}

//gets the ticket that manages the given ticket
fun getTicketManager[t: Ticket] : one TicketSystem{
(line + insideMarket + pastTickets).t
}

////checks if the two markets are the result of a new ticket insertion
pred checkEqualStateMarketPlusNewTicket[t: Ticket, m,m1 : Market]{
m1.ticketManager.(pastTickets + insideMarket) = m.ticketManager.(pastTickets + insideMarket)  and 
m1.ticketManager.line= m.ticketManager.line + t and
m1.dispensers=m.dispensers and m1.cashDesks=m.cashDesks and m1.entrances=m.entrances and 
m1.freeExit=m.freeExit and m1.manager=m.manager and m1.departments=m.departments
}

//checks if the two users are the result of a new virtual ticket insertion
pred checkEqualStateVUserPlusNewTicket[t: VirtualTicket, u,u1: VirtualUser]{
u1.userVTickets=u.userVTickets + t and u1.userVisits = u.userVisits and u1.userDevice = u.userDevice
}

//checks if the two users are the result of a new visit insertion
pred checkEqualStateVUserPlusNewVisit[v: Visit, u,u1: VirtualUser]{
u1.userVTickets=u.userVTickets  and u1.userVisits = u.userVisits + v and u1.userDevice = u.userDevice
}

//checks if the two users are the result of a new physical ticket insertion
pred checkEqualStatePUserPlusNewTicket[t: PhysicalTicket, u,u1: PhysicalUser]{
u1.userPTickets=u.userPTickets + t
}


//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////FACTS//////////////////////////////////////

//No market gives more tickets per time slot than the max allowed by the shop manager
fact{
all m: Market, d: Date, t: TimeSlot | 
	let marketTickets=  getAllTickets[m.ticketManager] |
		#(marketTickets & ticketDate.d & ticketTimeSlot.t) <= m.ticketManager.maxUsersPerSlot
}

//definition of user safety
fact{
all vu: VirtualUser | vu.userStatus = Safe iff 
				( no t: Ticket, ts: TicketSystem  | t != none and t in (vu.userVTickets + vu.userVisits) and
					 t in ts.insideMarket and #(ts.insideMarket) > ts.maxUsersPerSlot )
all pu: PhysicalUser | pu.userStatus = Safe iff 
				( no t: Ticket, ts: TicketSystem  | t != none and t in pu.userPTickets and
					 t in ts.insideMarket and #(ts.insideMarket) > ts.maxUsersPerSlot )
}

//each ticket can be scanned at most 2 times: 2 times is a past ticket that has entered and exited, 1 time is only entered, 0 times is in line
fact {
all t:Ticket | 
	#scannedBy[t] <= 2  and
	//ticket is past if it has been scanned 2 times, one at entrance and one at exit
	( (#scannedBy[t]  = 2 ) implies ( let ts = getTicketManager[t] | t in ts.pastTickets and #(scannedBy[t]  & (ticketManager.ts).entrances) = 1 and #(scannedBy[t]  & ((ticketManager.ts).freeExit + (ticketManager.ts).cashDesks.reader)) = 1)) and
	//ticket is inside if it has been scanned 1 time at entrance
	(#scannedBy[t]  = 1  iff let ts =  getTicketManager[t] | t in ts.insideMarket and #(scannedBy[t]  & (ticketManager.ts).entrances) = 1 ) and
	//ticket is in line if it has been scanned 0 times and it is not referring to a past Date, it the latter is true then the ticket is past (ticket invalidated because of user not presenting)
	( #scannedBy[t]  = 0 implies ( (no t1: Ticket | t1 != t and getTicketManager[t1] = getTicketManager[t]  and t1 in getTicketManager[t1].pastTickets and #scannedBy[t1]  = 2 and 
										(t1.ticketDate != getTicketManager[t1].currentDate and t.ticketDate = t1.ticketDate or 
											t1.ticketTimeSlot != getTicketManager[t1].currentTimeSlot  and t.ticketDate = t1.ticketDate and t.ticketTimeSlot=t1.ticketTimeSlot )) implies
																										 t in getTicketManager[t].line else t in  getTicketManager[t].pastTickets))
}

//each physical ticket is generated by one dispenser belonging to the ticket's market
fact{
all pt: PhysicalTicket | one d: TicketDispenser | pt in d.distributedTickets and dispensers.d = ticketManager.((line + insideMarket + pastTickets).pt)
}

//no same Ticket in two different markets' TicketSystem, in any of the states (inside, past, in line)
fact {
no disj ts1,ts2: TicketSystem |
	 #( getAllTickets[ts1] & getAllTickets[ts2]) != 0
}

//no same dispenser/cash desks/departments/ticketManager for disjoint markets
fact {
no disj m1,m2: Market |
	 #(m1.dispensers & m2. dispensers + m1.cashDesks & m2.cashDesks +
		 m1.departments & m2.departments + m1.ticketManager & m2.ticketManager) != 0
}

//each ticket has a different QRCode
fact {
no disj t1,t2: Ticket |
	 #(t1.ticketCode & t2.ticketCode)!= 0
}

//each category is associated to a Department in each Market
fact{
all disj d1,d2: Department | departments.d1 = departments.d2 implies no c: Category | c in d1.categories and c in d2.categories
}

//different markets have no same QRcodeReader
fact{
all disj m1,m2: Market |  (m1.freeExit + m1.entrances + m1.cashDesks.reader) & (m2.freeExit + m2.entrances + m2.cashDesks.reader) = none
}

//each Device has a different GPS device
fact {
all disj d1,d2: SmartDevice |
	(d1.localizationDevice != none and d2.localizationDevice != none) implies d1.localizationDevice != d2.localizationDevice
}

//each ticket system is associated to one and only one market
fact{
all t: TicketSystem | 
	#(ticketManager.t) = 1
}

//eachQRCodeReader is associated to a desk, an entrance or an exit
fact {
all qr: QRCodeReader | #(freeExit.qr + entrances.qr + reader.qr) = 1
}

//each QRCode is associated to one ticket
fact{
all c: QRCode | #(ticketCode.c) = 1 
}

//each ticket dispenser is associated to one market
fact{
all td: TicketDispenser | #(dispensers.td) = 1
}

//each cashDesk is associated to one market
fact{
all cd: CashDesk | #(cashDesks.cd) = 1
}

//each department is associated to one market
fact{
all d: Department | #(departments.d) = 1
}

//each item is associated to one category
fact{
all i: Item | #(products.i) = 1
}

//each GPS is associated to a SmartDevice
fact {
all g: GPS | #(localizationDevice.g) =1 
}

//each SmartDevice is associated to a Virtual User
fact {
all sd: SmartDevice | #(userDevice.sd) =1 
}

//each ticket of any type belongs to a correct type of user
fact{
all vt: VirtualTicket |  #(userVTickets.vt) = 1
all pt: PhysicalTicket | #(userPTickets.pt) = 1
all vs: Visit | #(userVisits.vs) = 1
}

///////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////GOALS AND PREDICATES///////////////////////////////////////////////	


//G3. User inside stores are safe
assert allUsersInsideStoresAreSafe{
all u: User | u.userStatus= Safe
}

//G5. If there are avavilable time slots in the current date, user can get a ticket and be put in line
pred vUserGetsTicket[m,m1: Market, u,u1: VirtualUser]{
some ts: TimeSlot | ts in m.ticketManager.currentDate.(m.ticketManager.availableSlots) and
				some t: Ticket | t.ticketDate = m.ticketManager.currentDate and t.ticketTimeSlot = ts and 
				t in m1.ticketManager.line and
				checkEqualStateMarketPlusNewTicket[t, m,m1] and
				checkEqualStateVUserPlusNewTicket[t, u,u1]
}

//G5. If there are available time slots in the current date, physical user can get a ticket from the dispenser
pred pUserGetsTicket[m,m1: Market, u,u1: PhysicalUser]{
some ts: TimeSlot | ts in m.ticketManager.currentDate.(m.ticketManager.availableSlots) and
				some t: Ticket | t.ticketDate = m.ticketManager.currentDate and t.ticketTimeSlot = ts and 
				t in m1.ticketManager.line and m1.dispensers.distributedTickets =m.dispensers.distributedTickets + t and
				checkEqualStateMarketPlusNewTicket[t, m,m1] and
				checkEqualStatePUserPlusNewTicket[t, u,u1]
}

//G6. If the selected date and time slot are available, virtual user can book a visit in that date and time slot
pred vUserBooksVisit[m,m1: Market, u,u1: VirtualUser,ts: TimeSlot, d: Date]{
 	(d->ts) in m.ticketManager.availableSlots and 
	some v: Visit | v.ticketDate = d and v.ticketTimeSlot = ts and 
	checkEqualStateVUserPlusNewVisit[v,u,u1] and checkEqualStateMarketPlusNewTicket[v,m,m1]	
}

//User cannot shop whitout having registered their entrance scanning QRCode
assert  noExitWithoutEntering{
no t: Ticket | (one qrReader: QRCodeReader | t.ticketCode in qrReader.scanned and qrReader in (Market.freeExit + Market.cashDesks.reader)) and
			no qrReader: QRCodeReader | t.ticketCode in qrReader.scanned and qrReader in Market.entrances
}

run vUserGetsTicket for 5
run vUserBooksVisit for 5
run pUserGetsTicket for 5
pred show{}

check allUsersInsideStoresAreSafe for 5
run show for 5 but exactly 1 Department,exactly 2 Category,exactly 1 Market,exactly 1 StoreManager,exactly 1 TicketDispenser,exactly 1 CashDesk,exactly 2 VirtualUser,exactly 1 PhysicalUser, exactly 4 Ticket
