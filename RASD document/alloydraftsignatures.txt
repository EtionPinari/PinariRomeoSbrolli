sig Market{
dispensers: some TicketDispenser,
cashDesks: some CashDesk,
entrances: some QRCodeReader,
freeExit: some QRCodeReader,
manager: one StoreManager,
departments: set Department,
ticketManager : one TicketSystem
}{
freeExit & entrances  = none
freeExit & cashDesks.reader = none
entrances & cashDesks.reader = none
}

sig TicketSystem{
maxUsersPerSlot: one Int,
insideMarket: set Ticket,
line: set Ticket,
pastTickets: set Ticket,
currentTimeSlot: one TimeSlot,
currentDate: one Date,
availableSlots: Date -> TimeSlot
}{ //no ticket is in more different states at the same time
#(insideMarket & line)=0
#(insideMarket & pastTickets)=0
#(line & pastTickets)=0
//all tickets insideMarket are tickets booked for the current Date and Time Slot
all t: Ticket | t in insideMarket implies (t.ticketDate = currentDate and t.ticketTimeSlot = currentTimeSlot)
//Available Dates and Time Slots are the ones for which the number of tickets is less than the max number admitted to grant safety and that
// are not  Dates or Slots different from the current for which there are past tickets (No available Slots in past dates)
all d:Date, ts:TimeSlot | (d->ts) in availableSlots iff (#((insideMarket + line) &  ticketDate.d & ticketTimeSlot.ts) < maxUsersPerSlot and 
											no t: Ticket | t in pastTickets and (t.ticketDate != currentDate and d=t.ticketDate or t.ticketTimeSlot != currentTimeSlot and d=t.ticketDate and ts=t.ticketTimeSlot  ))
}

sig TicketDispenser{
distributedTickets: set PhysicalTicket
}

sig QRCode{}

sig QRCodeReader{
scanned: set QRCode
}

sig CashDesk{
reader: one QRCodeReader
}

abstract sig Person{}

sig StoreManager extends Person{}

abstract sig SafetyStatus{}
one sig Safe extends SafetyStatus{}
one sig UnSafe extends SafetyStatus{}

abstract sig User extends Person{
userStatus: one SafetyStatus
}
sig VirtualUser extends User{
userVTickets: set VirtualTicket,
userVisits: set Visit,
userDevice: some SmartDevice
}

sig PhysicalUser extends User{
userPTickets: set PhysicalTicket
}

sig Date{}
sig TimeSlot{}

abstract sig Ticket{
ticketDate: one Date,
ticketTimeSlot: one TimeSlot,
ticketCode: one QRCode
}
sig PhysicalTicket extends Ticket{}
sig VirtualTicket extends Ticket{}
sig Visit extends Ticket{}

sig Item{}

sig Category{
products: some Item
}

sig Department{
categories: some Category
}

sig SmartDevice{
localizationDevice: lone GPS
}

sig GPS{}


///////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////  /USEFUL FUNCTIONS///////////////////////////////////

fun scannedBy[t: Ticket] : set QRCodeReader {
 scanned.(t.ticketCode)
}

fun getAllTickets[ts: TicketSystem] : set Ticket {
 ts.insideMarket + ts.line + ts.pastTickets
}

fun getTicketManager[t: Ticket] : one TicketSystem{
(line + insideMarket + pastTickets).t
}

//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////FACTS//////////////////////////////////////

//no same Ticket in two different markets' TicketSystem, in any of the states (inside, past, in line)
fact {
no disj ts1,ts2: TicketSystem |
	 #( getAllTickets[ts1] & getAllTickets[ts2]) != 0
}

//no same dispenser/cash desks/departments/ticketManager for disjoint markets
fact {
no disj m1,m2: Market |
	 #(m1.dispensers & m2. dispensers + m1.cashDesks & m2.cashDesks +
		 m1.departments & m2.departments + m1.ticketManager & m2.ticketManager) != 0
}

//each ticket has a different QRCode
fact {
no disj t1,t2: Ticket |
	 #(t1.ticketCode & t2.ticketCode)!= 0
}


//each Device has a different GPS device
fact {
all disj d1,d2: SmartDevice |
	(d1.localizationDevice != none and d2.localizationDevice != none) implies d1.localizationDevice != d2.localizationDevice
}

//No market gives more tickets per time slot than the max allowed by the shop manager
fact{
all m: Market, d: Date, t: TimeSlot | 
	let marketTickets= m.ticketManager.insideMarket + m.ticketManager.line + m.ticketManager.pastTickets |
		#(marketTickets & ticketDate.d & ticketTimeSlot.t) <= m.ticketManager.maxUsersPerSlot
}

//each ticket system is associated to one and only one market
fact{
all t: TicketSystem | 
	#(ticketManager.t) = 1
}


//each ticket can be scanned at most 2 times: 2 times is a past ticket that has entered and exited, 1 time is only entered, 0 times is in line

fact {
all t:Ticket | 
	#scannedBy[t] <= 2  and
	//ticket is past if it has been scanned 2 times, one at entrance and one at exit
	( (#scannedBy[t]  = 2 ) implies ( let ts = getTicketManager[t] | t in ts.pastTickets and #(scannedBy[t]  & (ticketManager.ts).entrances) = 1 and #(scannedBy[t]  & ((ticketManager.ts).freeExit + (ticketManager.ts).cashDesks.reader)) = 1)) and
	//ticket is inside if it has been scanned 1 time at entrance
	(#scannedBy[t]  = 1  iff let ts =  getTicketManager[t] | t in ts.insideMarket and #(scannedBy[t]  & (ticketManager.ts).entrances) = 1 ) and
	//ticket is in line if it has been scanned 0 times and it is not referring to a past Date, it the latter is true then the ticket is past (ticket invalidated because of user not presenting)
	( #scannedBy[t]  = 0 implies ( (no t1: Ticket | t1 != t and getTicketManager[t1] = getTicketManager[t]  and t1 in getTicketManager[t1].pastTickets and 
										(t1.ticketDate != getTicketManager[t1].currentDate and t.ticketDate = t1.ticketDate or 
											t1.ticketTimeSlot != getTicketManager[t1].currentTimeSlot  and t.ticketDate = t1.ticketDate and t.ticketTimeSlot=t1.ticketTimeSlot )) implies
																										 t in getTicketManager[t].line else t in  getTicketManager[t].pastTickets))
}

//different markets have no same QRcodeReader
fact{
all disj m1,m2: Market |  (m1.freeExit + m1.entrances + m1.cashDesks.reader) & (m2.freeExit + m2.entrances + m2.cashDesks.reader) = none
}

//eachQRCodeReader is associated to a desk, an entrance or an exit
fact {
all qr: QRCodeReader | #(freeExit.qr + entrances.qr + reader.qr) = 1
}


//each QRCode is associated to one ticket
fact{
all c: QRCode | #(ticketCode.c) = 1 
}

//each ticket dispenser is associated to one market
fact{
all td: TicketDispenser | #(dispensers.td) = 1
}

//each cashDesk is associated to one market
fact{
all cd: CashDesk | #(cashDesks.cd) = 1
}

//each department is associated to one market
fact{
all d: Department | #(departments.d) = 1
}


//each category is associated to a Department in each Market
fact{
all disj d1,d2: Department | departments.d1 = departments.d2 implies no c: Category | c in d1.categories and c in d2.categories
}

//each item is associated to one category
fact{
all i: Item | #(products.i) = 1
}

//each GPS is associated to a SmartDevice
fact {
all g: GPS | #(localizationDevice.g) =1 
}

//each SmartDevice is associated to a Virtual User
fact {
all sd: SmartDevice | #(userDevice.sd) =1 
}

//each ticket of any type belongs to a correct type of user
fact{
all vt: VirtualTicket |  #(userVTickets.vt) = 1
all pt: PhysicalTicket | #(userPTickets.pt) = 1
all vs: Visit | #(userVisits.vs) = 1
}

//each physycal ticket is generated by one dispenser belonging to the ticket's market
fact{
all pt: PhysicalTicket | one d: TicketDispenser | pt in d.distributedTickets and dispensers.d = ticketManager.((line + insideMarket + pastTickets).pt)
}


//definition of user safety
fact{
all vu: VirtualUser | vu.userStatus = Safe iff 
				( no t: Ticket, ts: TicketSystem  | t != none and t in (vu.userVTickets + vu.userVisits) and
					 t in ts.insideMarket and #(ts.insideMarket) > ts.maxUsersPerSlot )
all pu: PhysicalUser | pu.userStatus = Safe iff 
				( no t: Ticket, ts: TicketSystem  | t != none and t in pu.userPTickets and
					 t in ts.insideMarket and #(ts.insideMarket) > ts.maxUsersPerSlot )
}

//Goal G3
assert allUsersInsideStoresAreSafe{
all u: User | u.userStatus= Safe
}

//User cannot shop whitout having registered their entrance
assert  noExitWithoutEntering{
//TODO
}



pred show{}

check allUsersInsideStoresAreSafe for 5
run show for 10 but 1 TicketDispenser,1 Category, 1 Item,1 SmartDevice,1 CashDesk, 3 QRCodeReader
run {#pastTickets = 3 
#scanned=5
}  for 7 but 1 TicketDispenser,1 Category, 1 Item,1 SmartDevice,1 CashDesk, 3 QRCodeReader, exactly 2 Date,2 TimeSlot
