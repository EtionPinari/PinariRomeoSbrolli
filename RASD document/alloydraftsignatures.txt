sig Market{
dispensers: some TicketDispenser,
cashDesks: some CashDesk,
entrances: some QRCodeReader,
freeExit: some QRCodeReader,
manager: one StoreManager,
departments: set Department,
ticketManager : one TicketSystem
}{
freeExit & entrances  = none
freeExit & cashDesks.reader = none
entrances & cashDesks.reader = none
}

sig TicketSystem{
maxUsersPerSlot: one Int,
insideMarket: set Ticket,
line: set Ticket,
pastTickets: set Ticket,
currentTimeSlot: one TimeSlot,
currentDate: one Date
}{ //no ticket is in more different states at the same time
#(insideMarket & line)=0
#(insideMarket & pastTickets)=0
#(line & pastTickets)=0
all t: Ticket | t in insideMarket implies (t.ticketDate = currentDate and t.ticketTimeSlot = currentTimeSlot)
}

sig TicketDispenser{
distributedTickets: set PhysicalTicket
}

sig QRCode{}

sig QRCodeReader{
scanned: set QRCode
}

sig CashDesk{
reader: one QRCodeReader
}

abstract sig Person{}

sig StoreManager extends Person{}

abstract sig User extends Person{
}
sig VirtualUser extends User{
userVTickets: set VirtualTicket,
userVisits: set Visit
}

sig PhysicalUser extends User{
userPTickets: set PhysicalTicket
}

sig Date{}
sig TimeSlot{}

abstract sig Ticket{
ticketDate: one Date,
ticketTimeSlot: one TimeSlot,
ticketCode: one QRCode
}
sig PhysicalTicket extends Ticket{}
sig VirtualTicket extends Ticket{}
sig Visit extends Ticket{}

sig Item{}

sig Category{
products: some Item
}

sig Department{
categories: some Category
}

sig SmartDevice{
localizationDevice: lone GPS
}

sig GPS{}

//////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////FACTS//////////////////////////////////////

//no same Ticket in two different markets' TicketSystem, in any of the states (inside, past, in line)
fact {
no disj ts1,ts2: TicketSystem |
	 #( ( ts1.insideMarket + ts1.line + ts1.pastTickets ) & ( ts2.insideMarket + ts2.line + ts2.pastTickets ) ) != 0
}

//no same dispenser/cash desks/departments/ticketManager for disjoint markets
fact {
no disj m1,m2: Market |
	 #(m1.dispensers & m2. dispensers + m1.cashDesks & m2.cashDesks +
		 m1.departments & m2.departments + m1.ticketManager & m2.ticketManager) != 0
}

//no item in two disjoint categories
fact {
no disj c1,c2: Category |
	 #(c1.products & c2.products) != 0
}

//each ticket has a different QRCode
fact {
no disj t1,t2: Ticket |
	 #(t1.ticketCode & t2.ticketCode)!= 0
}


//each Device has a different GPS device
fact {
all disj d1,d2: SmartDevice |
	(d1.localizationDevice != none and d2.localizationDevice != none) implies d1.localizationDevice != d2.localizationDevice
}

//No market gives more tickets per time slot than the max allowed by the shop manager
fact{
all m: Market, d: Date, t: TimeSlot | 
	let marketTickets= m.ticketManager.insideMarket + m.ticketManager.line + m.ticketManager.pastTickets |
		#(marketTickets & ticketDate.d & ticketTimeSlot.t) <= m.ticketManager.maxUsersPerSlot
}

//each ticket system is associated to one and only one market
fact{
all t: TicketSystem | 
	#(ticketManager.t) = 1
}


//each ticket can be scanned at most 2 times: 2 times is a past ticket that has entered and exited, 1 time is only entered, 0 times is in line

fact {
all t:Ticket | 
	let qrReaders = scanned.(t.ticketCode) | 
	#qrReaders <= 2  and
	(#qrReaders = 2  iff one ts: TicketSystem | t in ts.pastTickets and #(qrReaders & (ticketManager.ts).entrances) = 1 and
				#(qrReaders & ((ticketManager.ts).freeExit + (ticketManager.ts).cashDesks.reader)) = 1) and

		(#qrReaders = 1  iff one ts: TicketSystem | t in ts.insideMarket and #(qrReaders & (ticketManager.ts).entrances) = 1 ) and

	 (#qrReaders = 0  iff one ts: TicketSystem | t in ts.line)
	
}

//different markets have no same QRcodeReader
fact{
all disj m1,m2: Market |  (m1.freeExit + m1.entrances + m1.cashDesks.reader) & (m2.freeExit + m2.entrances + m2.cashDesks.reader) = none
}

//eachQRCodeReader is associated to a desk, an entrance or an exit
fact {
all qr: QRCodeReader | #(freeExit.qr + entrances.qr + reader.qr) = 1
}


//each QRCode is associated to one ticket
fact{
all c: QRCode | #(ticketCode.c) = 1 
}

//each ticket dispenser is associated to one market
fact{
all td: TicketDispenser | #(dispensers.td) = 1
}

//each cashDesk is associated to one market
fact{
all cd: CashDesk | #(cashDesks.cd) = 1
}

//each GPS is associated to a SmartDevice
fact {
all g: GPS | #(localizationDevice.g) =1 
}

//each ticket of any type belongs to a correct type of user
fact{
all vt: VirtualTicket |  #(userVTickets.vt) = 1
all pt: PhysicalTicket | #(userPTickets.pt) = 1
all vs: Visit | #(userVisits.vs) = 1
}

//each physycal ticket is generated by one dispenser belonging to the ticket's market
fact{
all pt: PhysicalTicket | one d: TicketDispenser | pt in d.distributedTickets and dispensers.d = ticketManager.((line + insideMarket + pastTickets).pt)
}



pred show{}


run show for 10 but 0 Department, 0 Item, 0 SmartDevice,1 CashDesk,3 TicketDispenser, 3 QRCodeReader,0 Visit

